**Декоратор** (англ. **Decorator**) відноситься до класу структурних шаблонів. Він використовується для динамічного розширення
функціональність об'єкта. Є гнучкою альтернативою успадкування.

Сенс полягає в тому, щоб можна було безболісно комбінувати різні декоратори у довільному порядку,
навішуючи їх у різні об'єкти. До певної міри, це схоже на технологію **traits**, за винятком того,
що декоратори динамічно навішуються на об'єкт, а **traits** статично на клас.

На прикладі ми маємо клас "Cheeseburger", який реалізує інтерфейс "BurgerInterface".
Тут ми помічаємо, що в класі "Cheeseburger" не вистачає сиру. Це основний інгредієнт чизбургера і добре нам дописати
його у клас. Але уявімо, що переписувати клас ми не можемо. "Давайте успадковуємо **`Cheeseburger`** і розширимо його", скажете ви.
А якщо нам потрібно ще щось додати до **Cheeseburger**? Знову успадкування.
А якщо потрібно це все поєднати і ще щось додати? Знову успадкування. Потім знову і знову...

Декоратор допомагає нам зробити це дедалі гнучкіше.

Так як наш абстрактний декоратор **`AbstractDecorator`** реалізує інтерфейс **`BurgerInterface`**,
ми можемо розширювати його лише на рівні абстракції.

Додамо сир засобами **`CheeseburgerCheeseDecorator`**.

Наш декоратор (спадкоємець **`AbstractDecorator`**), у конструктор чекає об'єкт типу **`BurgerInterface`**.
Як згадувалося вище, **`AbstractDecorator`** реалізує інтерфейс **`BurgerInterface`**. Але метод **`BurgerInterface->makeBurger()`**
він не реалізує, а позначає як абстрактний. Це означає, що спадкоємці мають реалізувати його.
Ось у ньому ми декоруватимемо наш чизбургер.

А тепер давайте поміняємо соус у чизбургері.

Створюємо новий декоратор **`CheeseburgerSauceDecorator`** (спадкоємець **`AbstractDecorator`**).
Тепер ми можемо розширювати будь-який об'єкт типу ** BurgerInterface **.
Це може бути як вихідний чизбургер без сиру (об'єкт **`Cheeseburger->makeBurger()`**), так і вже декорований з сиром (**`CheeseburgerCheeseDecorator->makeBurger()`**).